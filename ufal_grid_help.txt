/net/work/people/uzivatelskyu 50GB
/net/cluster/TMP  # nezalohovyny neomezena data
/net/projects # vystadial
/net/data  # corpusy etc

V home mate moznost mit 10GB.

Pokud v /ha/projects/ potom jenom v /ha/projects/vystadial , ale to bych nedoporucoval. Tam by se nemeli delat nejake experimenty. Tam se pouze odkladaji vice ci mene ziva data.

Potom je lepsi pouzivat lokalni HDD. Pokud chcete pouzivat loki (ma 6 jader a 8GB), coz je moje workstation, potom lokalni dat muzete udlozit v /mnt/h/tmp/oplatek.

Jinak data, ktera se casto meni (vypocetni uloziste) a maji byt dostupna z grid se ukladaji na /net/cluster/TMP/ napr. /net/cluster/TMP/oplatek




Cluster (shluk) neboli grid (mříž, síť) je skupina počítačů, na kterých běží software pro automatické umístění vašeho výpočtu na dosud nevytížený stroj. Cluster na ÚFALu se nazývá LRC (Linguistic Research Cluster) a clustrovací software na něm je Sun Grid Engine. Do clusteru jsou zařazené tyto počítače:

lrc.ufal.hide.ms.mff.cuni.cz: hlava clusteru. To znamená, že neslouží k výpočtům, ale ke správě fronty výpočtů, které se odesílají na výpočetní stroje v clusteru. Na hlavě se nemají pouštět žádné náročné výpočty a naopak na ostatní stroje v clusteru se mají výpočty odesílat výhradně prostřednictvím hlavy. Hlava má 2 procesory Intel Pentium D 3 <acronym title="Gigahertz">GHz</acronym> a 1 <acronym title="Gigabyte">GB</acronym> paměti. Ve skutečnosti existují hlavy dvě - lrc1 a lrc2, které sdílí IP adresu lrc.ufal.hide.ms.mff.cuni.cz. V případě výpadku jedné z hlav, přebírá kontrolu ta druhá. 

V následující tabulce je uveden seznam výpočetních uzlů clusteru (aktuální k 6.4.2012):
Jméno       CPU     RAM (GB)        OS
andromeda[1­13] 2xCore4 AMD Opteron 2.8 Ghz 32 Ubuntu 10.04
fireball[1­10] 2xCore4 Intel Xeon 3 Ghz 32 Ubuntu 10.04
hyperion[1­10] 2xCore2 Intel Xeon 3 Ghz 32 Ubuntu 10.04
lucifer[1­5] 2xCore4 Intel Xeon 2.4 Ghz 128 Ubuntu 10.04
orion[1­10] 2xCore4 Intel Xeon 2 Ghz 32 Ubuntu 10.04
pandora[1­10] 2xCore2 Intel Xeon 2.6 Ghz 16 Ubuntu 10.04
sol[1­8,11­13] 2xCore4 AMD Opteron 2 Ghz 16 Ubuntu 10.04
tauri[1­10] 2xCore4 Intel Xeon 3 Ghz 32 Ubuntu 10.04
tauri[1­10] 2xCore4 Intel Xeon 3 Ghz 32 Ubuntu 10.04
 cosmos 4xCore2 Intel Xeon 2.93 Ghz 256 Ubuntu 10.04
 iridium 2xCore4 Intel Xeon 1.86 Ghz 512 Ubuntu 10.04
 twister[1,2] 2xCore4 Intel Xeon 2.4 Ghz 48 Ubuntu 10.04

Frontovací systém umožňuje:
    využít na maximum výpočetní výkon
    poslat mnoho úloh k řešení najednou, úlohy budou ale spuštěny teprve, když na to bude čas
    spravedlivě dělit strojový čas mezi zájemce


JAK ZAČÍT
Jednou za život musíte provést Základní nastavení SGE, abyste SGE mohli používat.
    Do ~/.bash_profile zkopirujte
    . /net/projects/SGE/user/sge_profile

UKÁZKA UŽITÍ SGE

Tato posloupnost příkazů ukazuje, jak užít SGE:

ssh lrc2
  # přihlašte se na hlavu clusteru
echo "hostname; pwd" > skript.sh
  # vyrobte skript, který popisuje, co má úloha udělat
qsub -cwd -j y skript.sh
  # zařaďte úlohu do fronty.
  # Vlastně stačilo zavolat: qsub skript.sh
  # Ale dodatečné parametry zařídily:
  #  -cwd  ... skript bude spuštěn v aktuálním adresáři (a nikoli homu)
  #  -V    ... proměnné z vašeho prostředí budou zkopírovány do prostředí skriptu
  #  -j y  ... standardní a chybový výstup bude spojen (jako to dělá nohup)
  # Pořadí parametrů **je** důležité, co je za jménem skriptu, to se předává skriptu.
qstat
qstat -u '*' 
  # Podívejme se, jaké vaše úlohy běží.
  # SGE chvíli čeká, než skript opravdu spustí. Pro malinké úlohy tedy SGE může představovat
  # zbytečné zpoždění.
  # -u '*' ukáže úlohy všech uživatelů na clusteri
cat skript.sh.oXXXXX
  # vypište si výstup skriptu. XXXXX je ID jobu, které bylo přiděleno
  # qsubem. Čili druhé poslání do fronty starší log typicky nepřepíše.

A takto dopadl výstup našeho skriptu:

Warning: no access to tty (Bad file descriptor).
Thus no job control in this shell.
sol2.ufal.hide.ms.mff.cuni.cz
/export/home/bojar

DALŠÍ UŽITEČNÉ PŘÍKAZY A PARAMETRY:
qsub -o LOG.stdout -e LOG.stderr skript.sh
  # když chcete přesměrovat výstup skriptu do určených souborů
qsub -S /bin/bash
  # když chcete, aby skript běžel v bashi
qsub -V
  # když chcete předat proměnné prostředí
qdel \*
  # když chcete zrušit všechny své joby (rušit cizí nesmíte)

PRAVIDLA PRO SPRÁVNÉ POUŽÍVÁNÍ CLUSTERU

Základní pravidlo, které musíme všichni ctít, aby SGE plnilo svou úlohu dobře:
     Nespouštět úlohy ručně. (O ručně spuštěných úlohách SGE nemá informaci, klidně na daný uzel pošle ještě další úlohy z fronty.)

DALŠÍ DOPORUČENÍ:

Pokud možno používat "nice"

Dotaz: jak se kombinuje "nice" s "qsub"em? SGE je snad nyní nastaveno tak, že vše bude nicenuté. Každopádně je dobré do submitovaného skriptu na začátek napsat "renice 10 $$".

Uklízet po sobě lokální data, protože jinak si tam už nikdo nic užitečného nepustí.
Vyhnout se hodně divokému paralelnímu přístupu ke sdíleným diskům. NFS server to pak nepěkně zpomalí pro všechny. Distribuujte tedy i data.
Informovat SGE, kolik paměti úloha žere, aby na strojích nedošla paměť: 

qsub -l mf=10g …

Víc pravidel není.


SLUŠNÉ CHOVÁNÍ

Pokud chci spouštět úlohy, které poběží dlouhou dobu (hodiny, dny), nepustím je všechny najednou, aby cluster mohli využívat i ostatní.


TRIKY A OPENTLENÍ

==========================
~bojar/tools/shell/qsubmit
qsubmit je jako qsub, ale příjemnější:
nemusíte vyrábět skript, vyrobí ho sám (pozn.: nemusíte vyrábět skript, když použijete přepínač "-b y")
nemusíte připisovat "-cwd -j y -S /bin/bash"

~bojar/tools/shell/qsubmit "bashovy_prikaz < prismeruj > presmeruj 2> atd..."

lépe funguje "~{stepanek,pajas}/bin/qcmd" (nemusí se kvotovat parametry, správně počítá čas běhu…)
==========================
~zeman/bin/qsub.csh

Podobná věc pro "tcsh". Pokud bychom chtěli použít přesměrování standardního vstupu a výstupu, musíme ho dát do uvozovek nebo apostrofů, protože jinak se o něm "qsub.csh" nedozví, do skriptu k odeslání to neopíše a naopak jeho standardní vstup a výstup bude přesměrován. V přesměrování i v případných dalších argumentech, kde se vyskytují cesty k souborům, je vhodné použít úplné cesty. Pozor také na to, aby šlo o soubory a složky viditelné z celé sítě (tedy ne ve vašem "/mnt/h/tmp", například).

setenv SCRIPTFILE /tmp/`basename $1`.$$.csh
echo $* > $SCRIPTFILE
echo $*
echo qsub -cwd -V -S /bin/tcsh -m e $SCRIPTFILE
qsub -cwd -V -S /bin/tcsh -m e $SCRIPTFILE
qstat -u '*'
rm $SCRIPTFILE

Příklad spuštění:
qsub.csh $PARSER/train.pl "< $cesta/${xx}train.csts > $cesta/${xx}.1.stat"

(Kdybych místo uvozovek použil apostrofy, nerozbalily by se mi proměnné. První argument (název skriptu) klidně mohl být v uvozovkách spolu s přesměrováním. Dal jsem ho ven jen proto, že potom "qsub.csh" podle něj pojmenuje job ve frontě.)
==========================

TectoMT: devel/tools/cluster_utils/qrunblocks



Jako "$BRUNBLOCKS", ale spouští úlohy na gridu (bez pomoci /wiki/internal:jtred)
 qrunblocks filelist blocks


Skript zadanou hromádku souboru rozdělí do "-""-jobs" jobů. Každý job na gridu pak projede své soubory danou sekvencí bloků.



Soubory možno zadat filelistem, nebo pomocí "-""-glob" (stručně "-g"). Bloky možno vyjmenovat v jednom argumentu, nebo načíst ze souboru pomocí "–blocksfile SOUBOR".



Je nutné buď zadat "-""-tmt-root CESTA", nebo mít nastaven "$TMT_ROOT" podle inicializace TectoMT.



Parametr "-E" zpusobí, že se jobům z aktuálního prostředí procedí všechny proměnné "TMT_PARAM_*" (čili např. model parseru ap.). Případně je pomocí "-e" možné vyjmenovat některé (další) ručně.



Parametr "-""-sync" způsobí, že skript navíc bude (pasivně) čekat, až všechny joby skončí.



Výstup každého jobu jde do vlastního logu, "JOBNAME.o123456". Pokud JOBNAME nezadáte (parametr "-N"), užije se defaultní "qrunblocks".



Parametr "-""-join" způsobí, že se STDOUT všech kousků (ve správném pořadí) sebere a vypíše na hlavní STDOUT ("-""-join" implikuje "-""-sync"). Při spojování se také dělá důkladný test exitstatusů, takže "qrunblocks" končí úspěchem jen tehdy, když všechny joby uspěly.



Bez "-""-sync" nebo "-""-join" nezbývá, než kontrolovat, jestli logy jednotlivých jobů na konci nemají napsáno:  "Status: FAILED".




Monitorování úloh


 "qstat [-u user]" – seznam úloh aktuálně běžících / ve frontě

 "qhost" – dostupné zdroje

 "/SGE/REPORTER/LRC-UFAL/bin/lrc_users_real_mem_usage -u user -w" – aktuální využití paměti uživatelem

 "/SGE/REPORTER/LRC-UFAL/bin/lrc_users_limits_requested -w" – nárokované požadavky uživatelů

 "/SGE/REPORTER/LRC-UFAL/bin/lrc_nodes_meminfo" – vypis vsech uzlu a stav vytiznosti pameti.

 mem_total: celkova pamet uzlu

 mem_free: tedy kolik je jeste volne pameti z pametove quoty uzlu

 act_mem_free: kolik uzlu OPRAVDU zbyva volne pameti

 mem_used: kolik je pameti skutecne pouzito



 "/SGE/REPORTER/LRC-UFAL/bin/lrc_state_overview" – celkový přehled o clusteru

 celkovy pocet jader, pocet vyuzitych jader

 celkova velikost RAM, kolik je ji fyzicky nepouzite, kolik je ji jeste nerezervovane

 po jednotlivych uzivatelich (zrovna pocitajicich) – kolik jim bezi uloh, kolik jich maji ve fronte a kolik z nich je ve stavu hold



 "cat /SGE/REPORTER/LRC-UFAL/stats/userlist.weight" – seznam uživatelů clusteru seřazený podle dosavadní aktivity (počet odeslaných úloh × čas, který běžely), aktualizovaný každý den v noci

 MUNIN: GRAF VYTÍŽENOSTI CLUSTERU PODLE UŽIVATELŮ (VIDITELNÝ POUZE ZE SÍTĚ úfal
 https://ufaladm2.ufal.hide.ms.mff.cuni.cz/munin/ufal.hide.ms.mff.cuni.cz/lrc1.ufal.hide.ms.mff.cuni.cz/lrc_users.html



ČASTÉ A ZÁLUDNÉ PROBLÉMY



SUBMITNUTÝ JOB MŮŽE ZNOVU SUBMITOVAT

Danovy starší zkušenosti s clusterem PBS (nikoli SGE) říkaly, že tohle nejde. Ale jde to, aspoň u nás. Příkazy "qsub" a spol. jsou kromě hlavy clusteru dostupné i na všech strojích clusteru, samozřejmě pokud váš soubor ".bashrc", ".cshrc" apod. zajistí, že se i na nich provede inicializace prostředí SGE.




PROMĚNNÉ PROSTŘEDÍ, NASTAVENÍ VLASTNÍHO PROSTŘEDÍ

SGE spouští skripty v čistém prostředí. Nebuďte proto překvapeni, když vám skript na konzoli poběží dobře, ale po submitnutí fungovat nebude. Třeba nenašel potřebné programy v "$PATH"



Zatím nevím přesně, které ze souborů ".login", ".bashrc" ap. SGE spouští, jestli vůbec nějaké. Naopak, experimentálně jsem ověřil, že "qsub -S /bin/bash skript" nenačte žádný z ".bashrc", ".bash_profile", ".login", ani ".profile".



Z toho například také vyplývá, že bez ošetření se jako Java používá

 java version "1.5.0"
 gij (GNU libgcj) version 4.1.2 20070502 (Red Hat 4.1.2-12)


Pokud chcete submittovaný program pouštět ve svém oblíbeném prostředí (např. nastavení "PATH"), musíte v obalujícím skriptu příslušné ".bash*" načíst. Vždy je ale bezpečnější všude psát plné cesty, než spoléhat na PATH.




JINÝ SHELL


Abych mohl poslat nějakou úlohu do fronty, musím pro ni vyrobit vlastní skript. Budiž, vyrobil jsem vlastní skript:


#!/bin/bash
program > log.out 2> log.err



Když tento skript spustím, stane se očekávané. Přesměrují se výstupy z daného programu do souborů a je to.



Když takový skript submitnu, program se nespustí. V logu zjistím, že (standardní chybový) výstup shellu, který pouštěl můj skript praví kryptickou zprávu "Ambiguous redirect".



Nebudu vás napínat, zde je vysvětlení: SGE ignoruje první řádek skriptu (ve skutečnosti je pravda horší, hledá v něm nějaké parametry pro sebe) a spouští skript v "csh". Rozdíl mezi bashem a csh se v primitivních skriptech na první pohled nepozná, pozná se až v konstrukci if-then-else, a také v přesměrovávání. csh nerozumí přesměrování "2>"



Takto SGE přinutíte, aby použilo bash:


  qsub -S /bin/bash skript



Jinou možností je přesměrovat stderr a stdout pomocí syntaxe csh:


( command >stdout_file ) >&stderr_file




bashrc a podobné nesmí nic vypisovat na konzoli



Opsáno z http://www.sara.nl/userinfo/lisa/usage/batch/index.html.



It is important, that the files that are sourced during a login such as .bash_profile .profile .bashrc .login .cshrc don';t produce any output when a non-interactive login is done. If they do, changes are that your job will run, but that the batch system is unable to deliver to you the standard output and error files. In that case the status of your job will be ';E'; after the job is finished. Here is an example how you can test in a .bash_profile or .bashrc if this is an interactive login:


unset INTERACTIVE
/usr/bin/tty > /dev/null 2>&1
/usr/bin/test $? = 0 && INTERACTIVE=yes
...
if [ "$INTERACTIVE" ]; then
  ... commands only for truly interactive sessions ...
fi




Jak zjistit, jaké zdroje jsem pro svou úlohu požadoval

qstat -j 973884,982737,984029,984030,984031,984034,984036 | grep resource
hard resource_list:         mem_free=50g
hard resource_list:         mem_free=200g
hard resource_list:         mem_free=16g
hard resource_list:         mem_free=16g
hard resource_list:         mem_free=16g
hard resource_list:         mem_free=31g



SYNCHRONIZACE ÚLOH (V PERLU)



Pokud chci paralelizovat část úlohy (zde "muj_skript.pl"), obvykle potřebuju po provedení paralelní části posbírat výsledky a hlavně počkat na dokončení všech paralelních větví. Jak na to jednoduše:


 Obalím svůj skript pro běh na gridu – vytvořím "obaleno.sh":



#!/bin/bash
. /net/projects/SGE/user/sge_profile >/dev/null

qrsh -cwd -V -p -50 -l mf=5g -now no ';renice 10 $$ >/dev/null; ./muj_skript.pl $@';


 Ve svém hlavním skriptu ho pak zavolám a posbírám výsledky:



use FileHandle;
use IPC::Open2;
use threads;
use threads::shared;
my @threads;
my @results;
share(@results);
for (@inputs)   {
    my $t = async {
        my $reader; my $writer;
        my $pid = open2($reader, $writer, "./obaleno.sh " . $parametry); # Pustime ulohu na gridu
        die "Failed to open bipipe" if !$pid;
        $writer->autoflush(1); # Muzem zavolat, ale v gridu NEFUNGUJE!!!
        print $writer "$_\n" or die; # Poslem uloze v gridu vstup
        $writer->close(); # Dulezite, viz o 2 radky vyse
        for (<$reader>)    { # Posbirame vysledky
            chomp;
            {
               lock @results;
               push @results, $_;
            }
        }
        waitpid $pid, 0; # Pockame s ukoncenim vlakna na ukonceni ulohy v gridu
        return $? >> 8; # Pokusime se ziskat navratovou hodnotu (netestoval jsem)
    };
    push @threads, $t;
}
for (@threads)  { # Pockame, az to vsichni dodelaji
    die "Child exited with non-zero exit code" if $_->join();
}



Poznámky: 


 Pokud lze všechno předat parametry, nemusí se otevírat obousměrná roura a situace bude jednodušší

 Pokud "muj_skript.pl" začne psát na výstup dřív, než přečetl všechen vstup, dojde k deadlocku. Lze vyřešit obalením příkazy "cat" v "obaleno.sh".

 Celý příklad je k vidění v Czengu od <acronym title="Václav Novák">V.N.</acronym>


